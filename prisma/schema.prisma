// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"

  // Optional
  runtime                = "nodejs"
  moduleFormat           = "esm"
  generatedFileExtension = "ts"
  importFileExtension    = "ts"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Authentication and authorisation models
model User {
  id          String    @id @default(cuid())
  email       String    @unique
  username    String    @unique
  password    String
  firstName   String
  lastName    String
  isActive    Boolean   @default(true)
  lastLoginAt DateTime?
  createdAt   DateTime  @default(now()) @db.Timestamp(3)
  updatedAt   DateTime  @updatedAt @db.Timestamp(3)

  // Relations
  role   Role   @relation(fields: [roleId], references: [id])
  roleId String

  // Audit trail - which user performed actions
  stockTransactions     StockTransaction[]
  purchaseOrdersCreated PurchaseOrder[]    @relation("CreatedBy")
  salesOrdersCreated    SalesOrder[]       @relation("CreatedBy")
  auditLogs             AuditLog[]
  attachmentsUploaded   Attachment[]

  @@index([email])
  @@index([roleId])
  @@map("users")
}

// Role-based access control
model Role {
  id          String   @id @default(cuid())
  name        String   @unique // e.g., "Admin", "Manager", "Operator", "Viewer"
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now()) @db.Timestamp(3)
  updatedAt   DateTime @updatedAt @db.Timestamp(3)

  // Relations
  users       User[]
  permissions RolePermission[]

  @@map("roles")
}

// Permissions enum and junction table for fine-grained access control
enum PermissionType {
  // User management
  USERS_VIEW
  USERS_CREATE
  USERS_UPDATE
  USERS_DELETE

  // Inventory management
  INVENTORY_VIEW
  INVENTORY_CREATE
  INVENTORY_UPDATE
  INVENTORY_DELETE
  INVENTORY_ADJUST_STOCK

  // Orders management
  ORDERS_VIEW
  ORDERS_CREATE
  ORDERS_UPDATE
  ORDERS_DELETE

  // Locations and suppliers
  LOCATIONS_MANAGE
  SUPPLIERS_MANAGE

  // Reports and audit
  REPORTS_VIEW
  AUDIT_VIEW

  // System settings
  SETTINGS_MANAGE
}

model RolePermission {
  id         String         @id @default(cuid())
  role       Role           @relation(fields: [roleId], references: [id], onDelete: Cascade)
  roleId     String
  permission PermissionType

  @@unique([roleId, permission])
  @@map("role_permissions")
}

// Core inventory models
model Category {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  parentId    String? // Self-referential for hierarchical categories
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now()) @db.Timestamp(3)
  updatedAt   DateTime @updatedAt @db.Timestamp(3)

  // Relations
  parent   Category?       @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children Category[]      @relation("CategoryHierarchy")
  items    InventoryItem[]

  @@index([parentId])
  @@map("categories")
}

model InventoryItem {
  id            String   @id @default(cuid())
  sku           String   @unique // Stock Keeping Unit - primary identifier
  barcode       String?  @unique // EAN/UPC barcode for scanning
  name          String
  description   String?  @db.Text
  brand         String?
  model         String?
  unitOfMeasure String   @default("each") // each, kg, litre, metre, etc.
  costPrice     Decimal  @default(0) @db.Decimal(10, 2) // Purchase cost per unit
  sellingPrice  Decimal  @default(0) @db.Decimal(10, 2) // Selling price per unit
  minStockLevel Int      @default(0) // Minimum stock threshold for reorder alerts
  maxStockLevel Int? // Maximum stock level for inventory planning
  isActive      Boolean  @default(true)
  isSerialised  Boolean  @default(false) // Whether items have unique serial numbers
  createdAt     DateTime @default(now()) @db.Timestamp(3)
  updatedAt     DateTime @updatedAt @db.Timestamp(3)

  // Relations
  category   Category @relation(fields: [categoryId], references: [id])
  categoryId String

  variants           InventoryVariant[]
  stockLevels        StockLevel[]
  stockTransactions  StockTransaction[]
  purchaseOrderLines PurchaseOrderLine[]
  salesOrderLines    SalesOrderLine[]
  attachments        Attachment[]

  @@index([sku])
  @@index([barcode])
  @@index([categoryId])
  @@index([name]) // For text search
  @@map("inventory_items")
}

// For items with variations (size, colour, etc.)
model InventoryVariant {
  id           String   @id @default(cuid())
  sku          String   @unique // Variant-specific SKU
  barcode      String?  @unique
  attributes   Json // Flexible JSON for variant attributes {"size": "L", "colour": "Red"}
  costPrice    Decimal  @default(0) @db.Decimal(10, 2)
  sellingPrice Decimal  @default(0) @db.Decimal(10, 2)
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now()) @db.Timestamp(3)
  updatedAt    DateTime @updatedAt @db.Timestamp(3)

  // Relations
  parentItem   InventoryItem @relation(fields: [parentItemId], references: [id], onDelete: Cascade)
  parentItemId String

  stockLevels        StockLevel[]
  stockTransactions  StockTransaction[]
  purchaseOrderLines PurchaseOrderLine[]
  salesOrderLines    SalesOrderLine[]

  @@index([sku])
  @@index([barcode])
  @@index([parentItemId])
  @@map("inventory_variants")
}

// Physical locations where inventory is stored
model Location {
  id          String       @id @default(cuid())
  code        String       @unique // Short code like "WH001", "ZONE-A"
  name        String
  description String?
  type        LocationType
  parentId    String? // For hierarchical locations (building -> floor -> aisle -> shelf)
  isActive    Boolean      @default(true)
  createdAt   DateTime     @default(now()) @db.Timestamp(3)
  updatedAt   DateTime     @updatedAt @db.Timestamp(3)

  // Relations
  parent   Location?  @relation("LocationHierarchy", fields: [parentId], references: [id])
  children Location[] @relation("LocationHierarchy")

  stockLevels       StockLevel[]
  stockTransactions StockTransaction[]

  @@index([code])
  @@index([type])
  @@index([parentId])
  @@map("locations")
}

enum LocationType {
  WAREHOUSE
  STORE
  ZONE
  AISLE
  SHELF
  BIN
}

// Current stock levels at each location
model StockLevel {
  id                String    @id @default(cuid())
  quantityOnHand    Int       @default(0) // Physical stock count
  quantityReserved  Int       @default(0) // Stock allocated to orders but not yet picked
  quantityAvailable Int       @default(0) // quantityOnHand - quantityReserved
  lastCountedAt     DateTime?
  createdAt         DateTime  @default(now()) @db.Timestamp(3)
  updatedAt         DateTime  @updatedAt @db.Timestamp(3)

  // Relations - stock can be for either main item or variant
  item       InventoryItem?    @relation(fields: [itemId], references: [id], onDelete: Cascade)
  itemId     String?
  variant    InventoryVariant? @relation(fields: [variantId], references: [id], onDelete: Cascade)
  variantId  String?
  location   Location          @relation(fields: [locationId], references: [id])
  locationId String

  // Business rule: each item/variant can only have one stock level per location
  @@unique([itemId, locationId])
  @@unique([variantId, locationId])
  @@index([locationId])
  @@index([quantityOnHand])
  @@map("stock_levels")
}

// All stock movements and adjustments
model StockTransaction {
  id        String               @id @default(cuid())
  type      StockTransactionType
  quantity  Int // Positive for inbound, negative for outbound
  reason    String? // Human-readable reason for the transaction
  reference String? // External reference (PO number, SO number, etc.)
  cost      Decimal?             @db.Decimal(10, 2) // Cost per unit for this transaction
  createdAt DateTime             @default(now()) @db.Timestamp(3)

  // Relations - transaction can be for either main item or variant
  item       InventoryItem?    @relation(fields: [itemId], references: [id])
  itemId     String?
  variant    InventoryVariant? @relation(fields: [variantId], references: [id])
  variantId  String?
  location   Location          @relation(fields: [locationId], references: [id])
  locationId String
  user       User              @relation(fields: [userId], references: [id])
  userId     String

  @@index([type])
  @@index([createdAt])
  @@index([itemId])
  @@index([variantId])
  @@index([locationId])
  @@map("stock_transactions")
}

enum StockTransactionType {
  PURCHASE // Stock received from supplier
  SALE // Stock sold to customer
  ADJUSTMENT // Manual stock adjustment (count correction)
  TRANSFER // Movement between locations
  RETURN // Customer return
  DAMAGE // Stock damaged/written off
  THEFT // Stock theft/loss
  MANUFACTURING // Stock created through manufacturing
  CONSUMPTION // Stock consumed in manufacturing
}

// Supplier management
model Supplier {
  id            String   @id @default(cuid())
  code          String   @unique
  name          String
  contactPerson String?
  email         String?
  phone         String?
  address       Json? // Flexible address structure
  paymentTerms  String? // e.g., "30 days", "Net 15"
  currency      String   @default("GBP")
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now()) @db.Timestamp(3)
  updatedAt     DateTime @updatedAt @db.Timestamp(3)

  // Relations
  purchaseOrders PurchaseOrder[]

  @@index([code])
  @@index([name])
  @@map("suppliers")
}

// Purchase order management
model PurchaseOrder {
  id           String              @id @default(cuid())
  orderNumber  String              @unique // Human-readable order number
  status       PurchaseOrderStatus
  orderDate    DateTime            @default(now()) @db.Date
  expectedDate DateTime?           @db.Date // Expected delivery date
  receivedDate DateTime?           @db.Date // Actual delivery date
  totalAmount  Decimal             @default(0) @db.Decimal(12, 2)
  notes        String?             @db.Text
  createdAt    DateTime            @default(now()) @db.Timestamp(3)
  updatedAt    DateTime            @updatedAt @db.Timestamp(3)

  // Relations
  supplier    Supplier @relation(fields: [supplierId], references: [id])
  supplierId  String
  createdBy   User     @relation("CreatedBy", fields: [createdById], references: [id])
  createdById String

  lines PurchaseOrderLine[]

  @@index([orderNumber])
  @@index([status])
  @@index([orderDate])
  @@index([supplierId])
  @@map("purchase_orders")
}

enum PurchaseOrderStatus {
  DRAFT
  SENT
  CONFIRMED
  PARTIALLY_RECEIVED
  RECEIVED
  CANCELLED
}

model PurchaseOrderLine {
  id               String   @id @default(cuid())
  lineNumber       Int // Line number within the order
  quantityOrdered  Int
  quantityReceived Int      @default(0)
  unitPrice        Decimal  @db.Decimal(10, 2)
  lineTotal        Decimal  @db.Decimal(12, 2) // quantityOrdered * unitPrice
  createdAt        DateTime @default(now()) @db.Timestamp(3)
  updatedAt        DateTime @updatedAt @db.Timestamp(3)

  // Relations
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  purchaseOrderId String

  // Line can reference either main item or variant
  item      InventoryItem?    @relation(fields: [itemId], references: [id])
  itemId    String?
  variant   InventoryVariant? @relation(fields: [variantId], references: [id])
  variantId String?

  @@unique([purchaseOrderId, lineNumber])
  @@index([purchaseOrderId])
  @@map("purchase_order_lines")
}

// Sales order management
model SalesOrder {
  id           String           @id @default(cuid())
  orderNumber  String           @unique
  status       SalesOrderStatus
  orderDate    DateTime         @default(now()) @db.Date
  shipDate     DateTime?        @db.Date
  customerName String
  customerInfo Json? // Flexible customer information
  totalAmount  Decimal          @default(0) @db.Decimal(12, 2)
  notes        String?          @db.Text
  createdAt    DateTime         @default(now()) @db.Timestamp(3)
  updatedAt    DateTime         @updatedAt @db.Timestamp(3)

  // Relations
  createdBy   User   @relation("CreatedBy", fields: [createdById], references: [id])
  createdById String

  lines SalesOrderLine[]

  @@index([orderNumber])
  @@index([status])
  @@index([orderDate])
  @@map("sales_orders")
}

enum SalesOrderStatus {
  DRAFT
  CONFIRMED
  PICKING
  PACKED
  SHIPPED
  DELIVERED
  CANCELLED
}

model SalesOrderLine {
  id              String   @id @default(cuid())
  lineNumber      Int
  quantityOrdered Int
  quantityPicked  Int      @default(0)
  quantityShipped Int      @default(0)
  unitPrice       Decimal  @db.Decimal(10, 2)
  lineTotal       Decimal  @db.Decimal(12, 2)
  createdAt       DateTime @default(now()) @db.Timestamp(3)
  updatedAt       DateTime @updatedAt @db.Timestamp(3)

  // Relations
  salesOrder   SalesOrder @relation(fields: [salesOrderId], references: [id], onDelete: Cascade)
  salesOrderId String

  // Line can reference either main item or variant
  item      InventoryItem?    @relation(fields: [itemId], references: [id])
  itemId    String?
  variant   InventoryVariant? @relation(fields: [variantId], references: [id])
  variantId String?

  @@unique([salesOrderId, lineNumber])
  @@index([salesOrderId])
  @@map("sales_order_lines")
}

// File attachment system
model Attachment {
  id           String     @id @default(cuid())
  fileName     String
  originalName String
  mimeType     String
  fileSize     Int // File size in bytes
  filePath     String // Relative path to stored file
  entityType   EntityType // What type of entity this is attached to
  entityId     String // ID of the entity
  createdAt    DateTime   @default(now()) @db.Timestamp(3)

  // Relations
  uploadedBy      User           @relation(fields: [uploadedById], references: [id])
  uploadedById    String
  InventoryItem   InventoryItem? @relation(fields: [inventoryItemId], references: [id])
  inventoryItemId String?

  @@index([entityType, entityId])
  @@map("attachments")
}

enum EntityType {
  INVENTORY_ITEM
  SUPPLIER
  PURCHASE_ORDER
  SALES_ORDER
  USER
}

// Comprehensive audit logging
model AuditLog {
  id         String      @id @default(cuid())
  action     AuditAction
  entityType String // Table/model name that was affected
  entityId   String // ID of the affected record
  oldValues  Json? // Previous values (for updates and deletes)
  newValues  Json? // New values (for creates and updates)
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime    @default(now()) @db.Timestamp(3)

  // Relations
  user   User?   @relation(fields: [userId], references: [id])
  userId String?

  @@index([action])
  @@index([entityType])
  @@index([createdAt])
  @@index([userId])
  @@map("audit_logs")
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  PASSWORD_CHANGE
  STOCK_ADJUSTMENT
  ORDER_STATUS_CHANGE
}

// System-wide settings
model Setting {
  id          String          @id @default(cuid())
  key         String          @unique // e.g., "default_currency", "low_stock_threshold"
  value       Json // Flexible value storage
  dataType    SettingDataType // To help with type validation
  description String?
  isPublic    Boolean         @default(false) // Whether setting is visible to non-admin users
  createdAt   DateTime        @default(now()) @db.Timestamp(3)
  updatedAt   DateTime        @updatedAt @db.Timestamp(3)

  @@index([key])
  @@map("settings")
}

enum SettingDataType {
  STRING
  NUMBER
  BOOLEAN
  JSON
  DATE
}
